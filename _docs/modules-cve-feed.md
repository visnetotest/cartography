# Technical Requirements: CVE Feed Intelligence Module

This document provides a comprehensive technical breakdown of the CVE Feed intelligence module within Cartography. It is intended for developers who need to understand, integrate, and maintain this module.

## ðŸ—ï¸ Overview and Implementation Details

### Module Name and Purpose

*   **Module Name:** `cartography.intel.cve.feed.py`
*   **Purpose:** This module connects to the NIST National Vulnerability Database (NVD) 2.0 API to pull in comprehensive data about Common Vulnerabilities and Exposures (CVEs). It serves as the foundational source for all CVE information in the Cartography graph. Other security modules can then link their findings to the central `:CVE` nodes created by this feed.

### Data Flow

The module operates in two distinct modes: a bulk, per-year sync for initial data population, and an incremental sync to fetch recent modifications. Both modes use a batching and pagination strategy to handle large amounts of data gracefully.

```mermaid
graph TD
    A[Start CVE Sync] --> B{Sync mode?};
    B -- Yearly --> C[Get list of years to sync];
    B -- Incremental --> D[Get last modified date from graph];

    C --> E{Loop each year};
    E --> F[get_published_cves_per_year];
    F --> G[get_cves_in_batches];

    D --> H[get_modified_cves];
    H --> G;

    subgraph "Batching & Pagination"
        G --> I{For each 120-day batch...};
        I --> J[_call_cves_api];
        J --> K{Paginate through results (2000 per page)};
        K --> J;
    end

    K --> L[Combine all results];
    L --> M{Transform & Flatten JSON};
    M --> N{Load CVEFeed & CVE nodes};
    N --> O[Neo4j Graph];
```

### Technology Stack

*   **Programming Language:** Python
*   **Core Libraries:**
    *   `requests`: To make HTTP API calls to the NIST NVD API.
    *   `neo4j`: The official Python driver for Neo4j.

### Core Logic/Algorithm

1.  **Sync Strategy Determination:** A higher-level orchestrator determines whether to run a yearly bulk sync or an incremental sync based on modifications. It calls `get_published_cves_per_year()` for the former and `get_modified_cves()` for the latter.
2.  **Date Range Batching (`get_cves_in_batches`):** The NIST API is most efficient when queried over specific date ranges. To avoid overly large requests, this function takes a wide date range (like a full year) and breaks it into 120-day chunks. It then iterates through these smaller date windows.
3.  **API Calling and Pagination (`_call_cves_api`):**
    *   For each 120-day chunk, this function makes the actual API calls.
    *   It implements pagination to retrieve all results for the given time window, fetching up to 2000 results per page.
    *   **Rate Limiting:** It checks if an API key is provided. If not, it falls back to a slower, more conservative request interval (`DELAYED_SLEEP_TIME`) to avoid being blocked by the public NVD endpoint.
4.  **Data Transformation (`transform_cves`):** This is a critical step. The raw JSON from the NVD API is deeply nested. This function flattens the structure into a graph-friendly model. It extracts and promotes key data points:
    *   Pulls the English description from the list of all language descriptions.
    *   Extracts all reference URLs into a single list property.
    *   Flattens weakness enumerations (CWEs).
    *   Finds the "Primary" CVSS V3.1 metric, unnests its `cvssData` object, and promotes all its fields (e.g., `baseScore`, `baseSeverity`, `attackVector`) to top-level properties on the CVE node.
5.  **Data Loading (`load_cves`, `load_cve_feed`):**
    *   The transformed CVE data is loaded as `:CVE` nodes using Cartography's generic `load()` function and the `CVESchema`.
    *   Each `:CVE` node is connected to a central `:CVEFeed` node, which represents the NIST NVD feed itself.

### Dependencies

*   **External:** `requests`
*   **Internal (Cartography):** This module is foundational and has no other Cartography intel module dependencies. Other modules depend on *it*.

---

## ðŸ›ï¸ Architecture and Structure

### System Integration

This module provides the canonical source of truth for CVE data within the graph. Its primary purpose is to create a central set of `:CVE` nodes that other tools can link to. For example, a vulnerability scanner module would create its own `(:Finding)` nodes and then create a relationship to the `:CVE` node provided by this feed module. This de-duplicates CVE information and creates a powerful, interconnected graph.

`(:Host)-[:HAS_FINDING]->(:TenableFinding)-[:IDENTIFIES]->(:CVE {id: "CVE-2022-1234"})`
`(:CrowdstrikeHost)-[:HAS_VULNERABILITY]->(:SpotlightVulnerability)-[:HAS_CVE]->(:CVE {id: "CVE-2022-1234"})`

### Internal Components

*   **Data Fetching Orchestrators:**
    *   `get_modified_cves()`: Gets recently modified CVEs.
    *   `get_published_cves_per_year()`: Gets all CVEs for a given year.
*   **Core Fetching Logic:**
    *   `get_cves_in_batches()`: Breaks down large date ranges.
    *   `_call_cves_api()`: Handles API calls and pagination.
*   **Data Transformation:**
    *   `transform_cves()`: Flattens the nested NVD JSON into a graph-friendly format.
    *   `transform_cve_feed()`: Extracts metadata about the feed itself.
*   **Data Loading:**
    *   `load_cves()`: Loads CVE nodes and connects them to the feed.
    *   `load_cve_feed()`: Loads the central CVEFeed node.
*   **Graph State Helpers:**
    *   `get_cve_sync_metadata()`: Gets which years have already been synced.
    *   `get_last_modified_cve_date()`: Gets the timestamp of the most recently modified CVE in the graph.

---

## ðŸ”— External Interfaces and Contracts

### A. Public Interface (API)

This module is not typically run standalone but is orchestrated by a larger sync job. Its primary functions are:

*   `get_modified_cves(...)`: Fetches CVEs based on a modification window.
*   `get_published_cves_per_year(...)`: Fetches CVEs based on publication year.
*   `transform_cves(...)`: Transforms raw NVD JSON.
*   `load_cves(...)`: Loads transformed CVEs into Neo4j.

### B. Input Specification

*   **`http_session`**: A `requests.Session` object. (Required)
*   **`nist_cve_url`**: The URL for the NVD CVE 2.0 API. (Required)
*   **`api_key`**: An optional NIST NVD API key. Highly recommended for performance and to avoid rate-limiting.
*   **Date parameters:** A start and end date for the query.

### C. Output Specification

*   **Output Data Structure:** Functions return dictionaries of the raw or transformed data. The `load` functions have no return value but modify the graph state.
*   **Error Handling:** The `requests` session will raise an `HTTPError` on a non-200 API response. `ValueError` is raised if date ranges are invalid.

---

## ðŸŽ¯ Use Cases and Scenarios

*   **Use Case 1: Centralized CVE Information**
    *   **Scenario:** An analyst wants to look up the details of a specific CVE they heard about.
    *   **Integration:** A direct query on the `:CVE` node.
        ```cypher
        MATCH (c:CVE {id: 'CVE-2021-44228'})
        RETURN c.id, c.baseScore, c.baseSeverity, c.descriptions_en
        ```

*   **Use Case 2: Finding High-Severity Vulnerabilities**
    *   **Scenario:** A security team wants to get a list of all CVEs with a "CRITICAL" severity rating.
    *   **Integration:** A query filtering on the `baseSeverity` property.
        ```cypher
        MATCH (c:CVE)
        WHERE c.baseSeverity = 'CRITICAL'
        RETURN c.id, c.baseScore
        ORDER BY c.baseScore DESC
        ```

*   **Use Case 3: A Foundation for Correlation (Most Common)**
    *   **Scenario:** A vulnerability management team wants to see which hosts, as identified by their scanner, are affected by Log4Shell.
    *   **Integration:** This module provides the central `:CVE` node, which other modules link to. The query joins data from multiple sources.
        ```cypher
        MATCH (c:CVE {id: 'CVE-2021-44228'})<-[:HAS_CVE]-(finding)
        // finding could be a :SpotlightVulnerability, :TenableFinding, etc.
        MATCH (host)<-[:HAS_VULNERABILITY]-(finding)
        RETURN host.id, finding.id
        ```
